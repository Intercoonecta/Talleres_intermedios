---
title: "Datos temporales en R"
author: "Héctor Villalobos"
format: 
  gfm:
    toc: false
editor: visual
---

## Introducción

Para trabajar con datos temporales en R es importante conocer las diferentes clases disponibles para almacenar y representar esta información. Para ello, primeramente debemos saber como están estructurados los datos fuente.

Es muy común que en los archivos (ascii o excel) en los que tenemos o nos facilitan información se intercambie de posición el mes y el día en diferentes renglones ¡de la misma columna!, por lo que es sumamente importante verificar esto antes de importarlos en R, de lo contrario se obtendrán resultados inconsistentes. Por ello es importante adoptar un estilo consistente. Los mas apropiados son "dd-mm-yyyy" y "yyyy-mm-dd" donde cada letra representa un dígito para el día ("D"), mes ("M") y año ("Y").

![](fechas.jpg){width="266"}

Cuando nuestros datos incluyen horas, quedarían como "dd-mm-yyyy HH:MM:SS" y "yyyy-mm-dd HH:MM:SS". Cuando datos de este tipo se importan desde un archivo ascii con la función `read.table()`, en R serán de clase "character", lo cual dificultará su uso en gráficos o para realizar operaciones, por lo que debemos convertirlos a una clase especial para fechas o fecha-tiempo. Tal vez la clase más sencilla, cuando solo tenemos la fecha es "Date".

```{r}
fechas <- paste("2024", c("09", "10", "11", "12"), c("13", "18", "25", "31"), sep ="-")
fechas
class(fechas)
```

Como vemos, en este momento son clase "character". La conversión a la clase "Date" se logra con la función `as.Date().`

```{r}
fechas <- as.Date(fechas)
fechas
class(fechas)

```

Esta clase representa el número de días desde el 1 de enero de 1970.

```{r}
unclass(fechas)
origen <- as.Date("1970-01-01")
```

```{r}
fechas - origen
```

Con la función `Sys.time()` podemos obtener la fecha-hora actual en el "locale" de nuestra computadora, y al aplicar la función `as.Date()` la hora se descarta.

```{r}
ahora <- Sys.time()
ahora
as.Date(ahora)
```

Esto nos lleva a las siguientes clases que permiten guardar la hora y la zona de tiempo: **POSIXlt** y **POSIXct**. La primera es una lista de vectores `sec`, `min`, `hour` para el tiempo y `mday`, `mon` y `year` para la fecha. `wday` y `yday` para el día de la semana y el día del año. `isdst`, es una bandera para el horario de verano, y algunas veces `zone`, una cadena de texto para la zona de tiempo y `gmtoff`, que sería el *offset* en segundos del horario GMT. La función `strptime()` nos permite convertir una cadena de texto a la clase POSIXlt.

```{r}
dt <- strptime("2024-10-08 14:12:30", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
dt
class(dt)
```

Pare ver los vectores anteriores, usamos la función `unclass()` como antes.

```{r}
unclass(dt)
```

También podemos usar la función `as.POSIXlt()` con el mismo propósito, y si no indicamos la zona se ajustará a la de nuestra configuración

```{r}
X1 <- as.POSIXlt("2024-10-08 14:12:30")
X1
class(X1)
```

La siguiente clase, POSIXct, representa el número de segundos desde el inicio de 1970 (en UTC) como un vector numérico.

```{r}
X2 <- as.POSIXct("2024-10-08 14:12:30")
X2
class(X2)
```

hdhdhgd

```{r}
unclass(X2)

# definir origen
orig <- as.POSIXct("1970-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") 

# calcular la diferencia entre X2 y el origen
difftime(X2, orig, units = "s")
```

Datos diarios de temperatura

```{r}
# cargar paquete devtools
#library(devtools)

# instalar 'satin' desde github
#install_github("hvillalo/satin")

# cargar paquete satin
library(satin)
```

Importar datos de Copernicus

```{r}
thetao <- read.cmems("./datos/cmems_mod_glo_phy_my_0.083deg_P1D-m_1728505215428.nc")
```

inspeccionar objeto thetao

```{r}
class(thetao)
```

usaremos la temperatura potencial, thetao

```{r}
thetao
```

En este tenemos 731 días , del 2019-01-01 al 2020-12-31

```{r}
head(thetao@period$tmStart); tail(thetao@period$tmStart)
```

Haremos un mapa para elegir un punto y extraer los valores de temperatura en el nivel más superficial

```{r}
plot(thetao)
```

Tomemos por ejemplo un pixel a los 26° de lat N y 110° de lon W

```{r}
pt <- data.frame(x = -110, y = 26)
sst <- extractPts(thetao, points = pt)
dim(sst)
```

En sst están los valores de temperatura potencial para el punto seleccionado, en los 731 díasy para los 5 niveles de profundidad 731 $\times$ 5 = 3655. Las primeras seis columnas adicionales en sst contienen el id del punto o puntos elegidos, las coordenadas de latitud-longitud elegidas, las coordenadas del pixel más cercano donde hay datos y la distancia entres el punto elegido y el dato devuelto, solo como un control

```{r}
sst[ , 1:10]
```

Para repesentar la serie de tiempo podemos rearreglar nuestros datos extraidos de la siguiente manera

```{r}
fecha <- thetao@period$tmStart
tsm <- data.frame(fecha, temperatura = t(sst[ , 7:(731+6)]))
head(tsm)
```

Figura

```{r}
plot(tsm, type = "b", pch = 16, col = rgb(1, 0, 0, 0.2))
```

Si quisieramos los promedios mensuales

```{r}
library(lubridate)
tsm$mes <- month(tsm$fecha)
tsm$año <- year(tsm$fecha)
head(tsm)
```

Suavizado con promedios móviles

```{r}
library(smooth)
sm <- cma(tsm$temperatura, order = 30)
tsm$sm <- sm$fitted

plot(tsm$fecha, tsm$temperatura, type = "b", pch = 16, col = rgb(1, 0, 0, 0.2),
     xlab = "día", ylab = "temperatura")
lines(tsm$fecha, tsm$sm, lwd = 2)
```

Agregar por año mes

```{r}
tsm.mens <- aggregate(tsm$temperatura, by = list(mes = tsm$mes, año = tsm$año), mean)
head(tsm.mens)
```

```{r}
plot(as.Date(paste(tsm.mens$año, tsm.mens$mes, 15, sep = "-")), tsm.mens$x,
     xlab = "mes", ylab = "temperatura (°C)", type = "b")
```

\
