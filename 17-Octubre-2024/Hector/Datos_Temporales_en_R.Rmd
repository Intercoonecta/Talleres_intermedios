---
title: "Datos temporales en R"
author: "Héctor Villalobos"
format: 
  gfm:
    toc: false
editor: visual
---

## Introducción

Hablamos de datos temporales cuando las variables que se recolectan tienen asociada una fecha y posiblemente una hora. El uso correcto de estos datos depende de definir con toda claridad el formato en que esta información se almacena. Por ejemplo, en nuestros archivos (ascii o Excel) se puede guardar el año, mes y día en columnas separadas, o combinados en una misma columna como una cadena de texto o bien en un formato especializado de fecha (en el caso de Excel).

Usualmente se utilizan solo números, dos dígitos para el mes y el día y cuatro para el año, por lo que tendríamos algo así como "30-09-2024" (dd-mm-aaaa), aunque no necesariamente en ese orden. En otros casos podría escribirse el nombre del mes completo o abreviado, por ejemplo "2024/Sep/30" (aaaa/mmm/dd). El tiempo podría estar en una columna aparte o también combinado con la fecha: "2024-09-30 15:30:58" (aaaa-mm-dd hh:mm:ss).

Lo importante en todos los casos es la consistencia, no mezclar los nombres de los meses con números, ni escribir indistintamente "Sep", "sep" y "Septiembre", pero sobre todo, no invertir el orden del mes y el día. Es indisoensable revisar estos detalles en nuestros datos antes de importarlos en R.

![](fechas.jpg){fig-align="center" width="266"}

Al importar en R desde archivos ascii con la función `read.table()`, la variable con la fecha será reconocida como texto (clase `"character"`), lo cual dificultará su uso en gráficos o para realizar operaciones, por lo que debemos convertirlos a una clase apropiada. En cambio, al importar archivos Excel con la función `read_excel()` del paquete **readxl** usualmente ya pasan como clase `"POSIXct"`, si el formato no es ambiguo. A continuación se describen algunas de estas clases especializadas.

## Clase `"Date"`

Esta es tal vez la clase más sencilla cuando solo tenemos fechas.

```{r}
fechas <- paste("2024", c("09", "10", "11", "12"), c("13", "18", "25", "31"), sep ="-")
fechas
```

En el ejemplo, el vector `fechas`, aunque parece contener fechas, es de clase `"character"`.

```{r}
class(fechas)
```

La conversión a la clase `"Date"` se logra con la función `as.Date()`. Esta función trata de determinar que parte de la cadena de texto representa al día, al mes y al año, al igual que el carácter que separa a cada elemento (en este caso "-"), aunque de igual manera podemos especificarlo nosotros mediante el argumento `format = "%Y-%m-%d"` que explicaremos más adelante.

```{r}
fechas <- as.Date(fechas)
fechas
class(fechas)
```

Esta clase se almacena como el número de días desde el 1 de enero de 1970.

```{r}
unclass(fechas)
```

Podemos verificar lo anterior definiendo el origen en la misma clase y restandolo a nuestro vector de fechas.

```{r}
origen <- as.Date("1970-01-01")
fechas - origen
```

Con la función `Sys.time()` podemos obtener la fecha-hora actual de acuerdo a la configuración local de nuestra computadora.

```{r}
ahora <- Sys.time()
ahora
```

La función `as.Date()` descarta la hora. Aquí se especifica la zona de tiempo de la configuración local de la computadora donde se creó este tutorial para evitar que se considere con horario UTC (tiempo universal coordinado, sucesor del tiempo medio de Greenwich o GMT) . Se pueden consultar los códigos de las zonas de tiempo con la función `OlsonNames()`.

```{r}
as.Date(ahora, tz = "America/Mazatlan")
```

## La clase `"POSIXlt"`

Las clases más utilizadas en R que permiten guardar la fecha, hora y la zona de tiempo son **"POSIXlt"** y **"POSIXct"**. La primera almacena esta información como una lista de vectores `sec`, `min`, `hour` para el tiempo; `mday`, `mon` y `year` para la fecha; `wday` y `yday` para el día de la semana y el día del año, respectivamente;`isdst`, es una bandera para el horario de verano; `zone` es una cadena de texto para la zona de tiempo; y `gmtoff` sería el *offset* en segundos del horario GMT. La función `strptime()` nos permite convertir una cadena de texto a la clase `"POSIXlt"`.

```{r}
dt <- strptime("2024-10-17 07:12:30", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
dt
class(dt)
```

Aquí vemos de nueva cuenta el uso del argumento `format` indicando que el año está primero e incluye la centuria (`%Y`), seguido del mes como número de dos dígitos (`%m`) y el día (`%d`) separados por un guión. Después siguen los códigos para la hora (`%H`), minutos (`%M`) y segundos (`%S`) separados por ":". Si nuestra cadena de texto hubiera sido "24-Oct.-17" el argumento cambiaría a `format = "%y-%b-%d"`. Estos códigos y otros más se pueden consultar en la ayuda de la función `strptime()`.

Para ver los vectores mencionados antes, usamos nuevamente la función `unclass()`.

```{r}
unclass(dt)
```

Notar que el mes es 9 porque se cuenta desde 0. En el caso del año, el origen es 1900, por lo que 124 + 1900 = 2024.

También podemos usar la función `as.POSIXlt()` para convertir una cadena de texto a la clase `"POSIXlt"`. En este caso, si no lo indicamos la zona de tiempo se ajustará de acuerdo a nuestra configuración local.

```{r}
psx.lt <- as.POSIXlt("2024-10-17 07:12:30")
psx.lt
class(psx.lt)
```

## La clase `"POSIXct"`

Esta clase representa el número de segundos desde el primero de enero de 1970 (en UTC) como un vector numérico.

```{r}
psx.ct <- as.POSIXct("2024-10-17 07:12:30", tz = "UTC")
psx.ct
class(psx.ct)
```

Aplicando la función `unclass()` podemos ver el número de segundos transcurridos desde el origen mencionado antes.

```{r}
unclass(psx.ct)
```

Esto lo podemos comprobar fácilmente.

```{r}
# definir origen
orig <- as.POSIXct("1970-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") 

# calcular la diferencia entre psx.ct y el origen
difftime(psx.ct, orig, units = "s")
```

De acuerdo con la ayuda de R, la clase `"POSIXct"` es más conveniente para incluirse en *data frames*, mientras que `"POSIXlt"`es una forma más fácil de leer para el humano.

## Manipulación de datos temporales: temperatura potencial del mar diaria

Una vez explicadas las clases especializadas para fecha-tiempo en R, vamos a ilustrar la manipulación de este tipo de información utilizando el producto *Global Ocean Physics Reanalysis* (<https://doi.org/10.48670/moi-00021>) de Copernicus (<https://marine.copernicus.eu/>).

El archivo netCDF proporcionado (en la carpeta "datos") contiene valores diarios de temperatura potencial para una región del Golfo de California, México. El periodo abarca del primero de enero de 2019 al 31 de diciembre de 2020. En este archivo la información de la fecha podemos verla con el siguiente código.

```{r}
library(ncdf4)
ncf <- nc_open("./datos/cmems_mod_glo_phy_my_0.083deg_P1D-m_1728505215428.nc")
time <- ncf$dim$time$vals
head(time)
```

Inspeccionando un poco la información contenida en el archivo (tecleando `ncf` en la consola de R) podemos notar que estos valores corresponden al número de segundos desde el primero de enero de 1970

![](ncf.png){fig-align="center"}

Enotnces, la conversión apropiada sería

```{r}
time <- as.POSIXct(time, tz = "UTC", origin = "1970-01-01 00:00:00")
head(time)
```

Este proceso aunque no es complicado requiere varios pasos que se pueden implementar en una función que se ocupe de esto y de extraer el resto de la información del archivo netCDF. Un ejemplo es la función `read.cmems()` del paquete **satin**, que además prevee otros casos en los que el origen o las unidades pudieran ser diferentes (e.g. horas o días).

```{r}
# cargar paquete devtools
#library(devtools)

# instalar 'satin' desde github
#install_github("hvillalo/satin")

# cargar paquete satin
library(satin)
```

Importar el archivo netCDF anterior con la función `read.cmems()`, que se encarga entre otras cosas de identificar el formato en que las fechas están almacenadas.

```{r}
thetao <- read.cmems("./datos/cmems_mod_glo_phy_my_0.083deg_P1D-m_1728505215428.nc")
```

Ahora inspeccionamos el archivo importado, comenzando por la clase del objeto `"thetao"`.

```{r}
class(thetao)
```

Tecleando su nombre obtenemos un resumen de su contenido.

```{r}
thetao
```

Podemos ver que tenemos datos diarios de temperatura en °C, con una resolución espacial de 9.2 km. En total son 731 días, del primero de enero de 2019 al 31 de diciembre de 2020 y a 2 niveles de profundidad diferentes (0.49 y 1.54 m).

Con la función `str()` podemos ver la estructura de `thetao` y sus diferentes componentes.

```{r}
str(thetao)
```

Podemos extraer los diferentes componentes ("slots") de este objeto de clase S4 usando "\@". Por ejemplo el vector de latitudes `thetao@lat`, o los periodos (en este ejemplo solo algunos al inicio y otros al final de los 731 días).

```{r}
head(thetao@period$tmStart); tail(thetao@period$tmStart)
```

Para tener una impresión gráfica de los datos importados, podemos hacer un mapa de las temperaturas en el primer día de 2019 (por defecto).

```{r}
plot(thetao)
```

### Serie de tiempo en un pixel

Hasta aquí solo hemos descrito la estructura de los datos importados y como las fechas se convirtieron a una clase apropiada (`"POSIXct"`). Ahora veremos las ventajas de esto, para lo cual vamos a elegir un punto del mapa anterior y extraeremos los valores de temperatura en el nivel más superficial para todos los días contenidos en nuestros datos.

Tomemos por ejemplo el pixel con coordenadas 26° de lat N y 110° de lon W.

```{r}
pt <- data.frame(x = -110, y = 26)
sst <- extractPts(thetao, points = pt)
dim(sst)
```

En `sst` están los valores de temperatura potencial para el punto seleccionado, en los 731 días y para los 2 niveles de profundidad 731 $\times$ 2 = 1462. Las seis columnas adicionales en `sst` contienen el id del punto elegido, las coordenadas de latitud-longitud deseadas, las coordenadas del pixel más cercano donde hay datos y la distancia entre el punto elegido y el dato devuelto (en km), solo como control de calidad.

```{r}
sst[ , 1:10]
```

Para representar la serie de tiempo de la temperatura potencial en superficie podemos re-arreglar los datos extraídos incluyendo el periodo correspondiente de la siguiente manera.

```{r}
fecha <- thetao@period$tmStart
tsm <- data.frame(fecha, temperatura = t(sst[ , 7:(731+6)]))
head(tsm)
```

Si graficamos esta nueva tabla vemos como la fecha se ubica en el eje x y las etiquetas se ajustan al formato más conveniente (año-mes en este caso) para evitar saturar el gráfico con texto.

```{r}
plot(tsm, type = "b", pch = 16, col = rgb(1, 0, 0, 0.2))
```

### Promedios anuales y mensuales

Ahora, el paquete **lubridate** nos permite manipular de manera sencilla las fechas. Por ejemplo, si quisiéramos calcular promedios de temperatura por año o mes, necesitamos primero extraer de la columna fecha esta información.

```{r}
library(lubridate)
tsm$mes <- month(tsm$fecha)
tsm$año <- year(tsm$fecha)
head(tsm)
```

Ahora el promedio por año podría obtenerse con la función `tapply()` o `aggregate()`. La diferencia entre estas funciones es que la primera devuelve una matriz (o arreglo cuando hay más de tres dimensiones) y la segunda un *data frame*.

```{r}
tapply(tsm$temperatura, tsm$año, mean)
```

En el caso del promedio mensual, sin considerar el año sería

```{r}
aggregate(tsm$temperatura, list(mes = tsm$mes), mean)
```

y finalmente, por año y mes

```{r}
tapply(tsm$temperatura, list(tsm$mes, tsm$año), mean)
```

En este último caso la función `aggregate()` produce un *data frame* más apropiado para graficar.

```{r}
tsmXmes <- aggregate(tsm$temperatura, 
                      by = list(mes = tsm$mes, año = tsm$año), mean)
tsmXmes
```

Necesitamos combinar las columnas mes y año, definiendo además un día (el 1 en este ejemplo) para posicionar las etiquetas en un gráfico.

```{r}
fecha <- as.Date(paste(tsmXmes$año, tsmXmes$mes, "01", sep = "-"))
plot(fecha, tsmXmes$x, xlab = "mes", ylab = "Temperatura (°C)", type = "b", las = 1)
```

### Suavizado con promedios móviles

De igual manera podemos ilustrar el suavizado con promedios móviles usando la función `cma()` del paquete **smooth**. En este caso, como el vector suavizado queda del mismo tamaño que los datos podemos sobreponer ambos aprovechando la fecha.

```{r}
library(smooth)
sm <- cma(tsm$temperatura, order = 30)
tsm$sm <- sm$fitted

plot(tsm$fecha, tsm$temperatura, type = "b", pch = 16, col = rgb(1, 0, 0, 0.2),
     xlab = "día", ylab = "Temperatura (°C)", las = 1)
lines(tsm$fecha, tsm$sm, lwd = 2)
```

### Extracción de periodicidades 

Existen varios métodos para modelar estacionalidad en series de tiempo. Aquí vamos a ejemplificar la regresión periódica con descenso cíclico mediante el paquete **periods**.

```{r}
## Instalación

# library(devtools)
# install_github("hvillalo/periods")

library(periods)
```

Primero se calculan los periodos con descenso cíclico.

```{r}
tsm.cd <- cyclicDescent(x = tsm$temperatura, plots = FALSE)
```

En el resultado (`harmonics`) se muestran en orden los componentes armónicos detectados (periodo, amplitud, fase y retraso, así como la suma de cuadrados residual y R^2^, mientras que en `Stats` se presentan las pruebas de significancia para cada componente encontrado.

```{r}
tsm.cd$harmonics
tsm.cd$Stats
```

Cuando se define cuales son los periodos de interés se hace una estimación global mediante el modelo de regresión periódica. En este ejemplo consideraremos solo los primeros 10 periodos.

```{r}
op <- tsm.cd$harmonics$Period[1:10] # periodos de interés
perReg <-periodicRegModel(x = tsm$temperatura, periods = op) # modelo
perReg$model
```

El ajuste se hace por regresión lineal múltiple con la función `lm()`.

```{r}
ajuste <- lm(perReg$model, data = perReg$data)
summary(ajuste)
```

Quedando el modelo ajustado de la siguiente manera.

```{r}
plot_periodicReg(ajuste)
```

Si interesa ver los componentes armónicos finales, se usa la función `harmonics()`.

```{r}
harmonics(ajuste)
```

Podemos por último generar un gráfico final recuperando la información de la fecha y sumando la media de temperaturas que durante el proceso del descenso cíclico se removió.

```{r}
plot(tsm[, 1:2], type = "b", col = "grey50")
lines(tsm$fecha, fitted(ajuste) + mean(tsm$temperatura), col = "blue", lwd = 2)
```

\
