---
title: "Datos temporales en R"
author: "Héctor Villalobos"
format: 
  gfm:
    toc: false
editor: visual
---

## Introducción

Hablamos de datos temporales cuando las variables que se recolectan tienen asociada una fecha y posiblemente una hora. El uso correcto de estos datos depende de definir con toda claridad el formato en que esta información se almacena. Por ejemplo, en los archivos (ascii o Excel) se puede guardar el año, mes y día en columnas separadas, o combinados en una misma columna como una cadena de texto o bien en un formato especializado de fecha (en el caso de Excel).

Usualmente se usan solo números, por lo que tendríamos algo así como "30-09-2024" (dd-mm-aaaa), aunque en algunos casos podría escribirse como "2024/Sep/30" (aaaa/mmm/dd). El tiempo podría estar en una columna aparte o también combinado con la fecha: "2024-09-30 15:30:58" (aaaa-mm-dd hh:mm:ss).

Lo importante en todos los casos es la consistencia, y sobretodo no invertir el orden del mes y el día ni escribir indistintamente "Sep", "sep" y "Septiembre" . Es sumamente importante revisar esto antes de importar los datos en R.

![](fechas.jpg){fig-align="center" width="266"}

Al importar en R desde archivos ascii con la función `read.table()`, la clase de la variable con la fecha será `"character"`, lo cual dificultará su uso en gráficos o para realizar operaciones, por lo que debemos convertirlos a una clase apropiada. En cambio, al importar archivos Excel con la función `read_excel()` del paquete **readxl** usualmente ya pasan como clase `"POSIXct"`, si el formato no es ambiguo. A continuación se describen algunas de estas clases especializadas.

## Clase `"Date"`

Esta es tal vez la clase más sencilla cuando solo tenemos fechas.

```{r}
fechas <- paste("2024", c("09", "10", "11", "12"), c("13", "18", "25", "31"), sep ="-")
fechas
```

En el ejemplo, el vector `fechas` es de clase `"character"`.

```{r}
class(fechas)
```

La conversión a la clase `"Date"` se logra con la función `as.Date()`. Esta función trata de determinar que parte de la cadena de texto representa al día, al mes y al año, aunque de igual manera podemos especificarlo nosotros mediante el argumento `format = "%Y-%m-%d"` que veremos más adelante.

```{r}
fechas <- as.Date(fechas)
fechas
class(fechas)
```

Esta clase representa el número de días desde el 1 de enero de 1970.

```{r}
unclass(fechas)
origen <- as.Date("1970-01-01")
```

La resta siguiente nos debe dar los mismos valores obtenidos con `unclass(fechas)`.

```{r}
fechas - origen
```

Con la función `Sys.time()` podemos obtener la fecha-hora actual de acuerdo a la configuración local de nuestra computadora.

```{r}
ahora <- Sys.time()
ahora
```

Al aplicar la función `as.Date()` la hora se descarta.

```{r}
as.Date(ahora)
```

## La clase `"POSIXlt"`

Las clases más utilizadas en R que permiten guardar la fecha, hora y la zona de tiempo son **"POSIXlt"** y **"POSIXct"**. La primera almacena esta información como una lista de vectores `sec`, `min`, `hour` para el tiempo; `mday`, `mon` y `year` para la fecha; `wday` y `yday` para el día de la semana y el día del año, respectivamente;`isdst`, es una bandera para el horario de verano; `zone` es una cadena de texto para la zona de tiempo; y `gmtoff` sería el *offset* en segundos del horario GMT. La función `strptime()` nos permite convertir una cadena de texto a la clase `"POSIXlt"`.

```{r}
dt <- strptime("2024-10-18 07:12:30", format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
dt
class(dt)
```

Aquí vemos de nueva cuenta el uso del argumento `format` indicando que el año está primero e incluye la centuria (`%Y`), seguido del mes como número de dos dígitos (`%m`) y el día (`%d`) separados por un guión. Después siguen los códigos para la hora (`%H`), minutos (`%M`) y segundos (`%S`). Si nuestra cadena de texto hubiera sido "24-Oct.-18" el formato cambiaría a `"%y-%b-%d"`. Estos códigos y otros más se puden consultar en la ayuda de la función `strptime()`.

Para ver los vectores mencionados antes, usamos nuevamente la función `unclass()`.

```{r}
unclass(dt)
```

También podemos usar la función `as.POSIXlt()` para convertir una cadena de texto a la clase `"POSIXlt"`. En este caso, si no lo indicamos la zona de tiempo se ajustará de acuerdo a nuestra configuración local.

```{r}
psx.lt <- as.POSIXlt("2024-10-17 07:12:30")
psx.lt
class(psx.lt)
```

## La clase `"POSIXct"`

Esta clase representa el número de segundos desde el primero de enero de 1970 (en UTC) como un vector numérico.

```{r}
psx.ct <- as.POSIXct("2024-10-17 07:12:30", tz = "UTC")
psx.ct
class(psx.ct)
```

Aplicando la función `unclass()` podemos ver el número de segundos transcurridos desde el origen mencionado antes.

```{r}
unclass(psx.ct)
```

Esto lo podemos comprobar fácilmente.

```{r}
# definir origen
orig <- as.POSIXct("1970-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S", tz = "UTC") 

# calcular la diferencia entre psx.ct y el origen
difftime(psx.ct, orig, units = "s")
```

De acuerdo con la ayuda de R, la clase `"POSIXct"` es más conveniente para incluirse en *data frames*, mientras que `"POSIXlt"`es una forma más fácil de leer para el humano.

## Manipulación de datos temporales: temperatura potencial del mar diaria

Para ilustrar la manipulación de datos temporales utilizaremos información del producto *Global Ocean Physics Reanalysis* (<https://doi.org/10.48670/moi-00021>) de Copernicus (<https://marine.copernicus.eu/>).

El archivo netCDF proporcionado (en la carpeta "datos") contiene valores diarios de temperatura potencial para una región del Golfo de California, México. El periodo abarca del primero de enero de 2019 al 31 de diciembre de 2020. En este archivo la información de la fecha podemos verla con el siguiente código.

```{r}
library(ncdf4)
ncf <- nc_open("./datos/cmems_mod_glo_phy_my_0.083deg_P1D-m_1728505215428.nc")
time <- ncf$dim$time$vals
head(time)
```

Inspeccionando un poco el archivo (tecleando `ncf` en la consola de R) podemos notar que estos números corresponden al número de segundos desde el primero de enero de 1970: "units: seconds since 1970-01-01 00:00:00", por lo que la conversión apropiada sería

```{r}
time <- as.POSIXct(time, tz = "UTC", origin = "1970-01-01 00:00:00")
head(time)
```

Aunque este proceso pudiera parecer complicado, se encuentra ya codificado en la función `read.cmems()` del paquete **satin**, que además prevee otros casos en los que el origen o las unidades pudieran ser diferentes (e.g. horas o días).

```{r}
# cargar paquete devtools
#library(devtools)

# instalar 'satin' desde github
#install_github("hvillalo/satin")

# cargar paquete satin
library(satin)
```

Importar el archivo netCDF anterior con la función `read.cmems()`, que se encarga entre otras cosas de identificar el formato en que las fechas están almacenadas.

```{r}
thetao <- read.cmems("./datos/cmems_mod_glo_phy_my_0.083deg_P1D-m_1728505215428.nc")
```

Ahora inspeccionamos el archivo importado, comenzando por la clase del objeto `"thetao"`.

```{r}
class(thetao)
```

Tecleando su nombre obtenemos un resumen de su contenido.

```{r}
thetao
```

Podemos ver que tenemos datos diarios de temperatura en °C, con una resolución espacial de 9.2 km. En total son 731 días, del primero de enero de 2019 al 31 de diciembre de 2020 y a 2 niveles de profundidad diferentes (0.49 y 1.54 m).

Con la función `str()` podemos ver la estructura del objeto y sus diferentes componentes.

```{r}
str(thetao)
```

Podemos extraer los diferentes componentes ("slots") de este objeto de clase S4 usando "\@". Por ejemplo el vector de latitudes `thetao@lat`, o los periodos (en este ejemplo solo algunos del inicio y otros del final de los 731 días).

```{r}
head(thetao@period$tmStart); tail(thetao@period$tmStart)
```

Hasta aquí solo hemos descrito la estructura de los datos importados y como las fechas se convirtieron a una clase formal apropiada (`"POSIXct"`). Ahora veremos las ventadas de esto. Para ello primero haremos un mapa del primer periodo (por defecto) para elegir un punto y extraer los valores de temperatura en el nivel más superficial para todos los días contenidos en nuestros datos.

```{r}
plot(thetao)
```

Tomemos por ejemplo un pixel a los 26° de lat N y 110° de lon W

```{r}
pt <- data.frame(x = -110, y = 26)
sst <- extractPts(thetao, points = pt)
dim(sst)
```

En `sst` están los valores de temperatura potencial para el punto seleccionado, en los 731 días y para los 2 niveles de profundidad 731 $\times$ 2 = 1462. Las seis columnas adicionales en `sst` contienen el id del punto elegido, las coordenadas de latitud-longitud deseadas, las coordenadas del pixel más cercano donde hay datos y la distancia entre el punto elegido y el dato devuelto (en km), solo como control de calidad.

```{r}
sst[ , 1:10]
```

Para representar la serie de tiempo de la temperatura potencial en superficie podemos rearreglar los datos extraídos incluyendo el periodo correspondiente de la siguiente manera.

```{r}
fecha <- thetao@period$tmStart
tsm <- data.frame(fecha, temperatura = t(sst[ , 7:(731+6)]))
head(tsm)
```

Si graficamos esta nueva tabla vemos como la fecha se ubica en el eje x y las etiquetas se ajustan al formato más conveniente (año-mes en este caso) para evitar una saturar el gráfico con texto.

```{r}
plot(tsm, type = "b", pch = 16, col = rgb(1, 0, 0, 0.2))
```

Ahora, el paquete **lubridate** nos permite manipular de manera sencilla las fechas. Por ejemplo, si quisiéramos calcular promedios de temperatura por año o mes, necesitaríamos primero extraer de la columna fecha esta información.

```{r}
library(lubridate)
tsm$mes <- month(tsm$fecha)
tsm$año <- year(tsm$fecha)
head(tsm)
```

Ahora el promedio por año podría obtenerse con la función `tapply()` o `aggregate()`.

```{r}
tapply(tsm$temperatura, tsm$año, mean)
```

En el caso del promedio mensual, sin considera el año sería

```{r}
aggregate(tsm$temperatura, list(mes = tsm$mes), mean)
```

y finalmente, por año

```{r}
tapply(tsm$temperatura, list(tsm$mes, tsm$año), mean)
```

Estos promedios se pueden también obtener con `aggregate()` que produce un *data frame* más apropiado para graficar.

```{r}
tsm.mens <- aggregate(tsm$temperatura, 
                      by = list(mes = tsm$mes, año = tsm$año), mean)
tsm.mens
```

Figura

```{r}
plot(as.Date(paste(tsm.mens$año, tsm.mens$mes, 15, sep = "-")), tsm.mens$x,
     xlab = "mes", ylab = "Temperatura (°C)", type = "b")
```

De igual manera podemos ilustrar el suavizado con promedios móviles usando la función `cma()` del paquete **smooth**. En este caso, como el vector suavizado queda del mismo tamaño que los datos podemos sobreponer ambos explotando la fecha.

```{r}
library(smooth)
sm <- cma(tsm$temperatura, order = 30)
tsm$sm <- sm$fitted

plot(tsm$fecha, tsm$temperatura, type = "b", pch = 16, col = rgb(1, 0, 0, 0.2),
     xlab = "día", ylab = "Temperatura (°C)", las = 1)
lines(tsm$fecha, tsm$sm, lwd = 2)
```

\
