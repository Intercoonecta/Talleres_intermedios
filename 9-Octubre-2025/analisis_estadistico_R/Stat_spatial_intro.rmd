---
title: "Análisis estadístico de datos espaciales con R"
author: "Arelly Ornelas Vargas"
output: 
  html_document:
     mathjax: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

```


<!-- # Pre-requisitos -->
```{r, include=FALSE} 
packages <- c("sf", "spdep", "spatialreg", "vioplot", "corrplot", "ggplot2")
# Revisar si los paquetes están instalados
no_i<- packages[!packages %in% installed.packages()[, "Package"]]
# instalar paquetes faltantes
if (length(no_i) > 1) {
  install.packages(no_i, repos = "https://cran.rstudio.com/", dep = T)
}

library(spdep)   # datos espaciales
library(sf)      # datos espaciales
library(spatialreg) # modelos SAR/SEM
library(vioplot)   # gráficos de violín
library(corrplot)  # gráficos de correlación 
library(ggplot2)
```

### Objetivo
- En este tutorial se muestra como realizar un análisis estadístico con datos espaciales en R. 


### Directo a los datos
```{r read,  echo=T}

# Cargar datos
dm <- read.csv("datos_marinos.csv")

head(dm)   # primeras 6 filas
summary(dm)  # resumen estadístico

```
El dataset contiene información sobre algas en la costa de California. Las variables son: longitud, latitud, temperatura, clorofila y altura. 

> ¿Qué tipo de  variables contiene el dataframe?

> ¿Cuáles estadísticos descriptivos echan en falta?


Vamos a explorar los datos con gráficos.
```{r graphs1, echo=T}

#  Vistazo general de las variables
lapply(dm[,3:5], hist) # histogramas
lapply(dm[,3:5], boxplot) # boxplots

```


### ~ "Unión" de histogramas y boxplots
```{r graphs2, echo=T}
# Graficos de violín
par(mfrow=c(1,3)) # presentar 3 gráficos en 1 fila, 3 columnas
vioplot(dm$temperatura, col="lightblue", main="Temperatura")
vioplot(dm$clorofila, col="darkseagreen", main="Clorofila")
vioplot(dm$altura, col="lightpink", main="altura")
par(mfrow=c(1,1))  # volver a 1 gráfico
```


Los gráficos previos sirven para analizar las variables de manera individual. Para analizar las relaciones entre las variables, usaremos la correlación.

### Correlación

```{r correlation, echo=T}
(cor_mat <- cor(dm[,3:5])) # Matriz de correlaciones

# Gráficos de dispersión
pairs(dm[,3:5], pch=19, col="tan")


# Visualización con corrplot
corrplot(cor_mat, method = "circle", type = "upper",
         col = colorRampPalette(c("orangered", "white", "mediumseagreen"))(200),
         tl.col = "darkslateblue", tl.srt = 45, 
         addCoef.col = "midnightblue", number.cex = 0.8)
```


> ¿Qué variables hemos dejado de lado?

> ¿Por qué no las podemos obviar?


### Necesidad de modelos espaciales

Cuando tenemos este tipo de datos:

- abundancia de peces a lo largo de la costa.  
- Contaminación en estaciones de monitoreo.  
- Distribución de mamíferos marinos.  

Las observaciones **tienen dependencia  espacial**:  

- Se viola el supuesto  de independencia en modelos de regresión clásica  → estimaciones sesgadas e inferencias incorrectas.  


### Datos espaciales

```{r espacial, echo=T}

# Convertir a objeto espacial (CRS WGS84)
dm_sp <- st_as_sf(dm, coords = c("lon", "lat"), crs = 4326)


# Gráfico simple. El gradiente de color va de menor a mayor altura
# plot(dm_sp["altura"], main = "altura", pch=18, axes=T)

# Gráfico con escala. El tamaño de los puntos va de menor a mayor altura
# plot(dm_sp["altura"], 
#      cex = scales::rescale(dm_sp$altura, to=c(1,4)),
#      col = "darkblue", pch = 19,
#      main = "altura ", axes=T)



# Definir límites 
xlim <- c(min(dm$lon) - 0.2, max(dm$lon) + 0.2)
ylim <- c(min(dm$lat) - 0.2, max(dm$lat) + 0.2)


ggplot() +
  borders("world", xlim = xlim, ylim = ylim,
          fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = altura),
             size = 2) +
  scale_color_gradient(low = "lightblue", high = "darkred") +
  coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
  labs(title = "",
       x = "Lon", y = "Lat", colour = "Altura") +
  theme_minimal()

```

> Hacer el gráfico de las otras dos variables

```{r espacial2, echo=T}

ggplot() +
  borders("world", xlim = xlim, ylim = ylim,
          fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = clorofila),
             size = 2) +
  scale_color_gradient(low = "lightblue", high = "darkred") +
  coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
  labs(title = "",
       x = "Lon", y = "Lat", colour = "Clorofila") +
  theme_minimal()

```


### ¿Qué pasa con los cuantiles?

Con la opción `cut_number()`: podemos obtener cuantiles de las variables. En el ejemplo se ponen 4, por lo que se grafican los **cuartiles**.

```{r espacial3, echo=T}
ggplot(dm, aes(x = lon, y = lat)) +
  borders("world", xlim = range(dm$lon), ylim = range(dm$lat),
          fill = "gray90", colour = "gray70") +
  geom_point(aes(color = cut_number(altura, 4)), size = 2 ) +   # 4 cuartiles
  scale_color_brewer(palette = "RdYlBu", name = "Cuartiles") +
  coord_sf(xlim = range(dm$lon), ylim = range(dm$lat), expand = FALSE) +
  theme_minimal() +
  labs(title = "Mapa de altura por cuartiles")

quantile(dm$altura, probs = seq(0, 1, 0.25))

```
> ¿Cómo se modificaría el código para obtener los deciles o quintiles ?


### Bivariado

Representando dos variables en el mismo gráfico. En este gráfico podemos ver como el color del punto nos ayuda a ver la temperatura en esa posición y el tamaño nos ayuda a ver la altura.
```{r espacial4, echo=T}
ggplot(dm, aes(x = lon, y = lat)) +
  borders("world", fill="gray90", colour="gray70") +
  geom_point(aes(size = altura, color = temperatura), alpha = 0.7) +
  scale_color_viridis_c() +
  coord_sf(xlim = range(dm$lon), ylim = range(dm$lat)) +
  theme_minimal()

```

Otra opción es usar los cuartiles para colorear los puntos.
```{r espacial5, echo=T}
ggplot(dm, aes(x = lon, y = lat)) +
  borders("world", fill="gray90", colour="gray70") +
  geom_point(aes(size = altura, color = cut_number(clorofila, 4)), alpha = 0.7) +
  scale_color_brewer(palette = "RdYlBu", name = "Cuartiles") +
  coord_sf(xlim = range(dm$lon), ylim = range(dm$lat)) +
  theme_minimal()
```

Para ver los descriptivos de la variable altura según el valor de la variable clorofila:
```{r espacial6, echo=T}

aggregate(altura ~ cut_number(clorofila, 4), summary, data = dm)
```
> ¿Cómo se modificaría el código para solo representar los deciles de clorofila ?


### Outliers

Usando un box-plot podemos ver si nuestra variable tiene outliers. ¿Cómo se vería esto espacialmente?
```{r espacial7, echo=T}
# Recreamos un box-plot
vb <- dm$altura

q <- quantile(vb, probs = c(0.25, 0.5, 0.75))
iqr <- IQR(vb)

# Bigotes
lower <- q[1] - 1.5 * iqr
upper <- q[3] + 1.5 * iqr

# Variable que indica si el valor está por encima o por debajo de los bigotes
dm$boxcat <- cut(
  vb,
  breaks = c(-Inf, lower, q[1], q[2], q[3], upper, Inf),
  labels = c("Extremo bajo", "Q1", "Q2", "Q3", "Q4", "Extremo alto"),
  include.lowest = TRUE
)


xlim <- range(dm$lon) + c(-0.2, 0.2)
ylim <- range(dm$lat) + c(-0.2, 0.2)

ggplot(dm, aes(x = lon, y = lat)) +
  borders("world", xlim = xlim, ylim = ylim,
          fill = "gray90", colour = "gray70") +
  geom_point(aes(color = boxcat), size = 3) +   # El color depende de la variable boxcat
  scale_color_manual(values = c(
    "Extremo bajo" = "blue",
    "Q1"           = "lightblue",
    "Q2"           = "green",
    "Q3"           = "orange",
    "Q4"           = "red",
    "Extremo alto" = "darkred"
  )) +
  coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
  theme_minimal() +
  labs(title = "",
       x = "Longitud", y = "Latitud",
       color = "Categoría")
```

> Probemos con las otras dos variables: clorofila y temperatura

El gráfico previo **únicamente** nos permite ver valores atípicos **globales**, perooooo...

¿Cómo podemos identificar valores atípicos locales ?, es decir, puntos que son “raros” respecto a sus vecinos. Por ejemplo: una altura pequeña rodeada de otros valores altos.


### Dependencia espacial

Es de esperar  que una observación presenta mayor relación con las observaciones próximas que con las distantes.
- Valores similares se agrupan.
- Valores cercanos tienen a ser diferentes
- La variable toma valores distintos en distintas ubicaciones. No hay un patrón  visible

### ¿A quién puedo considerar vecinos?

- Contigüidad: dos regiones son vecinas si comparten frontera (útil con polígonos).

- Distancia fija: puntos dentro de un radio definido son vecinos.

- k vecinos más cercanos (k-NN): cada punto tiene como vecinos a los k puntos más cercanos.

Si analizáramos un mapa de polígonos, emplearíamos la contigüidad. Por ejemplo, podríamos considerar los valores de peso desembarcado en los distintos municipios de Baja California Sur.


La función `knearneigh()` de la librería `spdep` nos permite obtener la matriz de vecinos: devuelve una matriz con los índices de los puntos que forman parte del conjunto de los k vecinos más cercanos de cada punto

```{r vecinos, echo=T}

# Matriz de coordenadas
coords <- cbind(dm$lon, dm$lat)

nb_knn <- knn2nb(knearneigh(coords, k=4))

# Distancia (radio = 0.5 grados aprox.)
nb_dist <- dnearneigh(coords, 0,0.5)

par(mfrow=c(1,2))
plot(nb_knn, coords, main="Vecinos k-NN (k=4)", col="blue")
plot(nb_dist, coords, main="Vecinos por distancia", col="red")
```

Para seguir con el tutorial, usaremos k-NN.


### Matriz de pesos

Identificación de los puntos que cumplen con un criterio de cercanía.  
Se crea una matriz cuadrada $W$ de dimensión $n \times n$, donde $n$ es el número de puntos.  
Cada elemento $w_{ij}$ describe la relación espacial entre la ubicación $i$ y la ubicación $j$.
Vale uno si el punto $i$ es vecino de $j$ y cero en caso contrario. Se suele estandarizar por filas para que la suma de sus elementos sea igual a 1.

Al multiplicarla por una variable lo que se obtiene es la media ponderada de la variable para los puntos vecinos.


### Moran's I
Este índice evalúa si los valores de una variable tienden a estar agrupados, dispersos o aleatoriamente distribuidos en el espacio, es decir, compara la similitud de cada valor con los de sus vecinos inmediatos.

Toma valores  entre –1  y +1. Los valores cercanos a los extremos indican un patrón espacial; un valor de 0 corresponde a un patrón  aleatorio.

Para ver los patrones de agrupación local se utiliza el Indicador Local de Asociación de Moran (LISA):

- High-High (HH): valores altos rodeados de valores altos (clusters rojos).

- Low-Low (LL): valores bajos rodeados de valores bajos (clusters azules).

- High-Low (HL): valor alto rodeado de valores bajos (outlier local, naranja).

- Low-High (LH): valor bajo rodeado de valores altos (outlier local, celeste).



# Gráficamente

Ahora si podemos ver los outliers espacialmente.
```{r espacial8, echo=T}

W <- nb2listw(nb_knn, style = "W")

# Moran's I
lisa <- localmoran(dm$altura, W)

# Creando las etiquetas tomando como referencia a la media
dm$lisa_cat <- NA
ref_val <- mean(dm$altura)

for (i in 1:nrow(dm)) {
  if (dm$altura[i] >= ref_val & lisa[i,1] > 0) {
    dm$lisa_cat[i] <- "High-High"
  } else if (dm$altura[i] < ref_val & lisa[i,1] > 0) {
    dm$lisa_cat[i] <- "Low-Low"
  } else if (dm$altura[i] >= ref_val & lisa[i,1] < 0) {
    dm$lisa_cat[i] <- "High-Low"
  } else if (dm$altura[i] < ref_val & lisa[i,1] < 0) {
    dm$lisa_cat[i] <- "Low-High"
  }
}

dm$lisa_cat <- factor(dm$lisa_cat,
                            levels = c("High-High","Low-Low","High-Low","Low-High"))

# El gráfico
xlim <- range(dm$lon) + c(-0.2, 0.2)
ylim <- range(dm$lat) + c(-0.2, 0.2)

ggplot(dm, aes(x = lon, y = lat)) +
  borders("world", xlim = xlim, ylim = ylim,
          fill = "gray90", colour = "gray70") +
  geom_point(aes(color = lisa_cat), size = 3) +
  scale_color_manual(values = c(
    "High-High" = "darkred",
    "Low-Low"   = "darkblue",
    "High-Low"  = "orange",
    "Low-High"  = "skyblue"
  )) +
  coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
  theme_minimal() +
  labs(title = "Mapa de outliers espaciales LISA (Altura)",
       x = "Longitud", y = "Latitud",
       color = "Categoría LISA")

```



> ¿Qué más puedo hacer?

- Gráficos de dispersión con lag espacial `moran.plot()`
- Gráficos kernel density
- Correlogramas espaciales: muestra hasta qué escala espacial existe correlación
- Modelos espaciales: SAR (Spatial Autoregressive),  SEM (Spatial Error Model), la combinación de ambos SAC (Spatial Autoregressive Combined), etc.
- Heterocedasticidad espacial: cuando la variabilidad de los datos cambia en el espacio. Es decir, algunas zonas presentan mucha variabilidad en la variable de interés, mientras que otras son más homogéneas.

